simple_factory 简单工厂模式 *
strategy_model 策略模式 *
decorator_model 装饰模式 *
proxy 代理模式 *
factory 工厂模式 **
prototype_clone 原型模式
template_model  模板方法模式 **
facade 外观模式  **
builders 建造者模式
observer 观察者模式
抽象工厂模式（该模式我觉得可以被工厂模式完全替代）
state 状态模式 就是状态机，根据当前状态执行不同功能

适配器模式  感觉也就是外观模式的一种变种。也是代理模式的变种

memo 备忘录模式 用于存储进度之类很合适，还是要求客户端不需要自己内部的状态变化

组合模式（树叶与树干的关系） 
对象可能职责不同，但是需要统一管理并且有相同的功能，那么所有的对象都继承了同样的父类，父类可以定义一些通用的接口，这样就可以让用户忽略内部接口
在什么时候用
发现需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象时，就该考虑组合模式。这是一个树状的结构。
好处就是局部与整体即可以单独处理，又可以统一管理。

迭代器模式
就是foreach的方式。不放过任何一个队列里面的对象。
需要实现接口，iteratorget, next,first这3个


singleton 单例模式
单例模式就是一个类只实例化一次，具体实现就是通过
private构造函数，同时声明一个静态的GetInstance来获取对象。

桥接模式
桥接模式实际上就是将功能单一化，比如一个类里面可以根据不同的属性来属于不同的例子，那么我们就应该将属性分开，实现单一职责，不同的属性用不同的内部对象（类）来代替。这样就接触耦合。

命令模式
将具体的命令与一个执行命令的对象绑定，这样调用者就无需知道该怎么去执行这个命令，可以达到统一管理的目的。还可以添加、删除、修改。
将操作的对象和具体的操作给解耦了。

duty 责任链模式
主要是让用户的请求经过一系列的传递，而不需要让用户知道到底怎么传递的这个用于程序通讯的时候，应该可以，这个类似于装饰模式。用于加密解密操作。
并且这个还能指定顺序。指定权限。为每一个责任链上面的对象指定传递的对象。


中介者模式
实际上就是定义一个总管理的结构体，用于将各个模块集合在一起


flyweight 享元模式
其实具体实现就是一个内存池。当不同的功能使用的是相同的代码，那么就可以利用已经实例化过后的对象来实现功能，没必要重新实例化对象了。
这个节省了资源。功能之间如果相同，相同的逻辑称为享元的内部状态，如果发现除了几个参数以外其他都相同的，那就可以使用享元模式。
不同的参数叫做享元模式的外部状态。当大量过多的对象的时候，可以使用。在发现使用了很多相同逻辑的时候，也可以考虑把不变的和变化的专门提出来
弄成内在状态和外在状态。


解释器模式
感觉这个模式是用于是用于正则表达式。可以暂时不用。不考虑。

访问者模式
访问者模式是用于数据结构相对稳定的系统。
目的是要把处理从数据结构分离出来。很多系统可以按照算法和数据结构分开，如果数据结构很稳定，有有很多容易变化的算法的话，使用访问者就很适合。因为访问者模式很容易增加算法。

访问者模式给我的感觉是享元模式的变种。
因为访问者模式的大概思路就是，函数是不同的，变化的的只是输入的参数。由于访问者类的逻辑是不变化的，流程也是不变化的，变化的只是输入的参数（类），因此就将不变化的和变化的分割开了。


总结
创建型模式
单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式。

行为性模式
解释器模式、中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式
观察者模式、模板方法模式、命令模式、状态模式、职责链模式

结构性模式
适配器模式、桥接模式、组合模式、享元模式、代理模式、外观模式


设计的开始应该是从工厂方法开始，当需要更大的灵活性时，设计才需要选择其他创建者模式。

结构性模式
适配器模式、外观模式、桥接模式用的最多。
适配器用于不修改已有的类，然后做一个接口，相当于对内和对外做了隔离。
外观模式用于对客户端屏蔽内部子系统的细节。
桥接模式用于解构，类似udpserver的ucs这种全局的管理器。


行为型模式
观察者模式、模板方法模式、策略模式用的多
观察者模式其实就是发布订阅，这样可以让通知者不用关心观察者要做什么动作，只需要调用回调函数就可以了。两边解耦。
有重复代码的时候，考虑模板方法模式给去解耦
策略模式主要是封装不同的算法，因为只是算法不同，实际上结构还是相同的。参考linkserver的联动库重构的if_device_t和if_freedom_device_t

一套软件最好在设计上设计为表示层、业务逻辑层和数据访问层

在业务逻辑层与表示层之间可以增加一个业务外观层（外观模式，隔离客户端与内部系统）。这样表示层如何变化，业务逻辑层都可以不用关心。

设计模式的核心还是将不变化的和变化的分开，将类与类之间的耦合降低。多多利用多态的特性，将不变和变化的行为分开