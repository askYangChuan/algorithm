设计模式初衷
1，可维护，只局部修改就可以修改功能
2，可复用，函数的设计之类可以反复利用
3，可扩展，在不动原来功能的基础上就可以扩展功能等
4，灵活性好，可以根据需求将模块各种重组

怎么分类
面相对象编程，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。

面向对象的一种很重要的思维方式
封装变化点，将不变化的固定，将变化的在内部实现。这样需要修改的代码就少了很多。

下面的模式其实都是围绕封装、继承、多态来解决问题。

几个原则

单一职责原则（SRP）
就一个类而言，应该仅有一个引起它变化的原因。
一个类承担的职责过多，就等于把这些职责耦合，缺乏灵活性。
要判断是否分离一个类，就是看 是否能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责（ASD）

开放封闭原则
是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。
设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不修改了。如果新需求来了，我们增加一些类就完事了，原来的代码能不动就不动。我们在刚开始编码时假设没得变化，如果有变化发生的时候，我们就创建抽象来隔离以后发生的同类变化(这个还是可能要修改到原来的代码，但是最好只有这么一次)，做到以后再增加一个类似的需求时，可以不再修改原来的代码了

依赖倒转原则
抽象不应该依赖细节，细节应该依赖抽象。
A，高层模块不应该依赖底层模块。两个都应该依赖抽象。
B，抽象不应该依赖细节。细节应该依赖抽象。
说白了就是要针对接口编程，不要针对实现编程。比如电脑，CPU，内存，主板都是针对接口设计的。其他人不需要知道CPU或内存是如何实现的。只需要组合在一起就能用。
这个规则需要模块的接口要稳定。不需要怎么修改

里氏代换原则（LSP）
子类型必须能够代替掉他们的父类型
也就是说子对象必须要能够完全代替掉父类，调用者可以不用关心是父类还是子类。里氏代换原则是依赖倒转原则的基础。高级和低级模块最好都依赖接口编程。用什么语言编程不重要，如果编程时考虑的都是如何针对抽象编程而不是针对细节编程。即程序中所有雨来关系都是终止于抽象类或者接口，那就是面向对象的设计了。

迪米特法则(LoD)
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另外一个类的某个方法，可以通过第三者转发这个调用。
迪米特法则主要是强调类之间的松耦合。类之间的耦合越弱，越有利于复用。尽量降低类与类之间的联系。


下面的模式其实都是围绕封装、继承、多态来解决问题。
简单工厂模式
主要是为了解决对象创建问题。客户端只需要输入几个参数，就能在内部得到一个对象，然后调用公共的接口（父类函数），就能获取到结果

策略模式
如果遇到可能会经常变化的算法（不同时间用不同规则）等，就要用策略模式。
策略模式主要是为了封装变化，客户端只调用接口，只需要传递几个参数，不用关心接口内是如何实现的。接口内一般是根据传递的参数生成子类来提供功能。

装饰模式
装饰模式是为了给指定类对象A增加一些额外的功能，而不需要修改这个类或者继承子类。核心的实现方法就是创建一个新的抽象类和指定的这个类共同继承一个父类或接口。这样抽象类和指定类就有了公共的接口。同时抽象类需要拥有一个其父类的对象，这样就可以将对象封装到内部，这个具体情况看代码和UML。

使用场景：
为已有功能动态添加更多功能的一种方式
什么时候使用：
当新加入的功能只为了满足一些只在某种特定情况下才会执行的特殊行为的需要的时候。
优点：
把类中的装饰功能从类中移除，简化原有类。有效地把类的核心职责和特殊功能分开了。而且可以去掉相关类中重复的装饰逻辑。
注意最好让装饰类之间彼此独立。

装饰模式还有一种实现是还可以不用让指定类和抽象类继承相同类，可以让抽象类包含这个指定类就可以了，然后让继承的子类只有一个有具体的实例就好。这样我觉得可能比原始的装饰模式更好，因为原来的装饰模式还需要修改原来的类。这样可以完全不用。


代理模式
就是两个类共同继承相同的父类，实现相同的接口名字，然后其中一个类A包装类B，这样调用A，实际上是调用A里面的类B的相同函数。

实用场景
1，远程代理。为一个对象在不同地址空间提供局部代表。用于隐藏一个对象存在于不同地址空间的事实。（应该就是即RPC调用，在内部函数里面还包括了远程连接、认证、最后才是调用具体的函数，得到返回，然后返回给主函数这一些系列操作）

2，虚拟代理。是根据需要创建开销很大的对象。通过它来存放实例化需要很久的真实对象。就比如网站，有很多文字和图片，但是网站会很快打开，能看到所有文字，但是图片却是一张一张的下载后才能看到。哪些未打开的图片框，就是通过虚拟代理来替代真实图片。此时代理存储了真实
图片的路径和尺寸。

3，安全代理。用于控制访问权限的。
4，智能指引，可以在真实访问对象时，做一些额外的操作。


工厂模式
工厂模式就是将所有的变化都封装在内部，对外只需要修改创建的工厂的类型即可。
工厂模式是简单工厂模式的升级版，因为简单工厂模式在修改的时候，需要修改switch和case，这里导致了类被修改了，破坏了开放-封闭原则。因此这里为了解决这个问题，就将switch和case给拆散，创建了一个工厂类，将switch的选择分发到具体的工厂里面去。其实就是为了去掉if,else这种逻辑。每个工厂都有具体的实现。


原型模式
原型模式其实就是需要实现一个clone接口，让一个对象可以被另外一个对象被copy，至于是浅拷贝还是深拷贝，可以自己实现。

模板方法模式
这个主要是在父类的代码里面实现了大概的逻辑，规划好了执行函数的流程，而子类则具体实现具体的逻辑，将父类的抽象延迟到了子类的具体函数中
即将不变的步骤移动到父类，可变的操作移动到子类


外观模式
最常用的模式之一。
即用一个类Facade包装了整个系统，调用者不需要了解具体的实现细节。只需要知道类提供的接口就可以了。

外观模式使用场景
在设计初期阶段，就应该要有意识的将不同的两个层分开，比如经典三层架构，需要考虑在数据访问层、业务逻辑层、表示层的层与层之间建立外观Facade，这样可以为复杂的子系统提供一个简单的接口。降低耦合。
其次在开发阶段，子系统可能会创建越来越多的类，但是调用的用户程序是不需要知道的，所以这里增加外观Facade可以提供一个简单的接口，减少依赖。第三，在维护一个遗留的系统，如果有新需求，需要开发新系统，那么最好要做一个Facade类，隔离掉用新系统与旧系统，让锡系统与Facade对象交互，Facade与旧系统交互。

建造者模式
建造者模式和模板方法模式很类似，与模板方法模式的区别在于，将固定的逻辑移动到一个叫做指挥者的类里面管理，由指挥者控制逻辑（流程），而指挥者封装一个抽象类指针，然后调用抽象类的虚函数来实际调用子类对象的具体函数。耦合性比模板方法模式要低一点。但是会多一个控制类出来。
建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。
我的理解应该是单独弄出来一个控制类来确定对象的使用。然后控制类不关心到底在调用哪个类对象，只要接口一样就行。

观察者模式
观察者模式的重点是一个对象变化时需要通知多个对象，而通知的时候对象并不需要知道是哪些需要被通知，这就实现了解耦
这里需要学习下C++实现委托和C++11的function和bind的使用

抽象工厂模式
这个模式我觉得可以被工厂模式给替代

状态模式
这个就是状态机，这里C++更封装了一层，将具体的各个状态的行为都封装到一个子类去。这样修改某一状态的代码就只需要修改这个子类就可以了。这样大大降低了耦合

适配器模式  感觉也就是外观模式的一种变种。也是代理模式的变种

memo 备忘录模式 用于存储进度之类很合适，还是要求客户端不需要自己内部的状态变化

组合模式（树叶与树干的关系） 
对象可能职责不同，但是需要统一管理并且有相同的功能，那么所有的对象都继承了同样的父类，父类可以定义一些通用的接口，这样就可以让用户忽略内部接口
在什么时候用
发现需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象时，就该考虑组合模式。这是一个树状的结构。
好处就是局部与整体即可以单独处理，又可以统一管理。

迭代器模式
就是foreach的方式。不放过任何一个队列里面的对象。
需要实现接口，iteratorget, next,first这3个


singleton 单例模式
单例模式就是一个类只实例化一次，具体实现就是通过
private构造函数，同时声明一个静态的GetInstance来获取对象。

桥接模式
桥接模式实际上就是将功能单一化，比如一个类里面可以根据不同的属性来属于不同的例子，那么我们就应该将属性分开，实现单一职责，不同的属性用不同的内部对象（类）来代替。这样就接触耦合。

命令模式
将具体的命令与一个执行命令的对象绑定，这样调用者就无需知道该怎么去执行这个命令，可以达到统一管理的目的。还可以添加、删除、修改。
将操作的对象和具体的操作给解耦了。

duty 责任链模式
主要是让用户的请求经过一系列的传递，而不需要让用户知道到底怎么传递的这个用于程序通讯的时候，应该可以，这个类似于装饰模式。用于加密解密操作。
并且这个还能指定顺序。指定权限。为每一个责任链上面的对象指定传递的对象。


中介者模式
实际上就是定义一个总管理的结构体，用于将各个模块集合在一起


flyweight 享元模式
其实具体实现就是一个内存池。当不同的功能使用的是相同的代码，那么就可以利用已经实例化过后的对象来实现功能，没必要重新实例化对象了。
这个节省了资源。功能之间如果相同，相同的逻辑称为享元的内部状态，如果发现除了几个参数以外其他都相同的，那就可以使用享元模式。
不同的参数叫做享元模式的外部状态。当大量过多的对象的时候，可以使用。在发现使用了很多相同逻辑的时候，也可以考虑把不变的和变化的专门提出来
弄成内在状态和外在状态。
