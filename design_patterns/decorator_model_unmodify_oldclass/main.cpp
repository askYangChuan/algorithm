#include "decorator.h"


/*
装饰模式
该模式的特点是为了给指定类对象A增加一些额外的功能，而不需要修改这个类或者继承子类而设计。
核心实现是让原类与一个抽象类共同继承同一个父类A，然后抽象类需要封装一个父类A的对象，这样就可以让
抽象类派生的子类B也拥有原类或者兄弟类C，这样在调用装饰的函数时，无需关心其他对象是怎么实现的，只关心
自己实现的功能就好，最好在自己实现功能的时候先把其他装饰类的功能给先实现了。
这个类是我单独修改的东西，因为传统的修饰模式仍然需要修改原来的类，可能会破坏开放封闭原则，所以我这里
让抽象类不再和原来类继承同一个接口，而是让抽象类拥有原有类。同时只让一个抽象类的子类拥有该原有类的具体
实例，这样就可以不修改原来类，不过缺点就是每个原有类需要判断是否持有的原来类为空一下。可能在某种情况下
更实用一点。
*/

//如果在cpp里面包含c定义的头文件
extern "C" {
}

int main(int argc, char **argv)
{
	person p((char*)"小明");
	yifu y;
	kuzi k;
	y.set_person(&p);
	k.set_decorator_clothes(&y);
	k.do_operation();

	return 0;
}

